# Chapter 5. Transaction Processing and Recovery
## Concurrency
### Optimistic Concurrency Control
**Optimistic Concurrency Control(OCC)** 은 데이터베이스에서 트랜잭션 간 충돌이 드물게 발생한다고 가정하고,<br>
lock을 사용하지 않고 트랜잭션을 실행한 뒤 커밋 전에 validation 과정을 통해 충돌 여부를 확인하는 방식이다.<br>
락 없이 높은 동시성을 제공하지만, 충돌 시 재시도 -> 성능 저하

1. Read 단계
- 트랜잭션은 자신의 **프라이빗 컨텍스트**(private context)에서 모든 작업을 수행
- 이 단계에서는 트랜잭션의 **read set**(읽은 데이터)과 **write set**(수정할 데이터)이 결정
- 변경 사항은 외부에 공개되지 않습니다.
2. Validation 단계
- 트랜잭션이 커밋을 시도할 때, 현재까지 실행된 다른 트랜잭션들과의 **충돌 여부**를 검사합니다.
- 만약 읽은 데이터가 다른 트랜잭션에 의해 변경됐다면, 해당 트랜잭션은 rollback하고 처음부터 다시 시작
- 이 단계에서 Serializability 보장
3. Write 단계
- 검증을 통과한 트랜잭션만이 실제 데이터베이스에 **write set**을 커밋
- validation과 write 단계는 atomic하게 처리되어야 하며, 이 과정에서는 한 번에 하나의 트랜잭션만이 커밋을 진행

#### 검증 방식
- **Backward-oriented validation**: 이미 커밋된 트랜잭션들과의 충돌을 확인
- **Forward-oriented validation**: validation 단계에 있는 트랜잭션들과의 충돌을 확인

### Multiversion Concurrency Control
MVCC는 트랜잭션 일관성을 달성하기 위해 여러 레코드 버전을 허용하는 방식<br>
각 트랜잭션은 단일 데이터 버전이 아니라 여러 버전에 접근할 수 있으며, 트랜잭션 ID나 타임스탬프와 같은 단조 증가하는 값을 사용<br>
이를 통해 읽기와 쓰기 작업이 저장소 수준에서 최소한의 동기화만으로 진행<br>
즉, 새로운 값이 커밋되기 전까지는 이전 버전을 계속 읽을 수 있음<br>

### Pessimistic Concurrency Control
비관적 동시성 제어 방식은 낙관적 방식보다 더 보수적<br>
트랜잭션 간 충돌을 실행 중에 미리 감지하여, 충돌이 발생할 경우 트랜잭션의 실행을 abort<br>

#### timestamp ordering
각 트랜잭션은 고유한 타임스탬프를 가짐<br>
어떤 트랜잭션 연산을 허용할지 여부는, 더 이른 타임스탬프를 가진 트랜잭션이 이미 커밋되었는지에 따라 결정<br>
이를 구현하기 위해 트랜잭션 관리자는 값마다 **max_read_timestamp**와 **max_write_timestamp**를 유지함<br>

- **읽기 연산**: 만약 읽기 연산이 자신의 타임스탬프보다 더 최신의 **max_write_timestamp**를 가진 값을 읽으려 한다면 -> abort<br>
    이미 더 새로운 값이 존재하므로 트랜잭션 순서를 위반하기 때문
- **쓰기 연산**: 만약 쓰기 연산이 자신의 타임스탬프보다 더 최신의 **max_read_timestamp**를 가진 값을 덮어쓰려 한다면, 이는 최근에 읽힌 값과 충돌<br>
    하지만 자신의 타임스탬프보다 더 최신의 **max_write_timestamp**를 가진 값에 쓰기를 시도하는 경우는 허용<br>
    이 경우, 오래된 값에 대한 쓰기는 무시해도 안전하기 때문<br>
    Thomas Write Rule<br>

### Lock-Based Concurrency Control
여러 트랜잭션의 동시 접근 시, 충돌 방지의 목적으로 사용하는 방식<br>
트랜잭션이 데이터에 접근할 때 명시적으로 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 함<br>

#### 2PL(2 Phase Locking)
1. **Growing Phase**: 트랜잭션이 필요한 모든 락을 획득하는 단계<br>
2. **Shrinking Phase**: 트랜잭션이 이미 획득한 락을 해제하는 단계<br> 

트랜잭션은 한번이라도 락을 해제하면, 이후에는 새로운 락을 획득할 수 없음<br>

### Deadlocks
T1과 T2가 있고 두 트랜잭션 모두 L1과 L2라는 두 개의 리소스를 필요로 할 때,<br>
- T1이 L1을 획득하고 L2를 기다리는 상황
- T2가 L2를 획득하고 L1을 기다리는 상황
위의 두 가지가 동시에 발생하면 교착 상태(Deadlock)가 발생<br>

#### 처리법
1. Timeout<br>
장기 대기 중인 트랜잭션을 종료시키는 방법
2. Conservative 2PL<br>
operation을 수행하기 전에 필요한 모든 리소스에 대한 락을 획득하는 방법<br>
하지만 이렇게 하면 동시성에서 큰 제약이 걸림
3. Deadlock Detection<br>
waits-for graph를 사용하여 실행중인 트랜잭션들 간의 관계를 추적<br>
사이클이 생긴다면 deadlock이 발생한 것으로 간주하여 최근에 락을 요청한 트랜잭션을 abort<br>

### Locks vs Latches
lock은 논리적 무결성을 보장하는 것<br>
트랜잭션 단위로 관리되며 키에 대해 걸림<br>
트리 구조와는 별도로 존재하므로 데이터베이스 내부 구조를 보호하지는 않음<br>

latch는 물리적 무결성을 보장하는 것<br>
B-Tree와 같은 내부 저장 구조를 보호하여 여러 스레드가 동시에 구조를 변경하려고 할 때 충돌을 방지<br>
락보다 가볍고 적은 오버헤드를 가짐<br>
한 트랜잭션에서 여러 스레드가 동시에 트리를 수정하려고 할 때, latch를 사용하여 충돌을 방지<br>

### Readers-writer lock
여러 읽기 작업이 동시에 수행될 수 있도록 접근을 허용하고,<br>
쓰기 작업은 독점적으로 수행되도록 하는 락<br>
읽기 작업은 서로 간섭하지 않으므로 동시 실행을 허용하지만,<br>
쓰기 작업은 다른 읽기나 쓰기와 격리해야 데이터의 일관성을 보장할 수 있음<br>

### Latch Crabbing
트리구조에서 루트부터 리프까지 내려가면서 래치를 획득하게 되는데,<br>
자식 노드의 래치를 획득하면 부모 노드의 래치를 바로 해제하여 동시성을 개선하는 방식<br>

삽입이나 삭제시에는 자식 노드가 안전할 때만 부모 노드의 래치를 해제<br>

### Blink-Trees
동시성 제어에 유리한 B-Tree의 변형<br>
sibling link를 추가로 가지므로 분할되거나 구조가 바뀌는 도중에도 다른 작업을 안전하게 이어서 할 수 있음<br>

Blink-Tree는 half-split 상태를 허용함<br>
부모 노드에서는 아직 자식 포인터가 변경되지 않았지만 형제 노드를 통해 이미 연결된 상황을 말함<br>
분할이나 병합 과정에서도 트리 전체의 일관성이 유지됨

노드 분할 시 부모 포인터를 바로 업데이트하지 않고, 형제 노드를 통해 연결된 상태를 유지해도 된다는 장점도 있음<br>
락을 위한 경쟁이 줄고 읽기 작업이 대체로 빠르게 수행될 수 있음<br>