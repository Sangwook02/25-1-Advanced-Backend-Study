# Chapter 7. Log-Structured Storage

## Read, Write, and Space Amplification
최적의 압축 전략을 구현하기 위한 첫번째 방법은<br>
중복 레코드가 차지하는 공간을 회수하고 공간 오버헤드를 줄이는 것이다.<br>
이렇게 하면 쓰기 증폭이 늘기 때문에 데이터를 연속적으로 쓰지 않는 대안이 있다.<br>
이 대안은 쓰기 증폭은 줄지만 읽기와 공간의 측면에서 단점이 있다.<br>

### RUM Conjecture
읽기, 쓰기, 공간의 3가지 요소 중에 둘을 최적화하면 하나는 안 좋아질 수밖에 없다는 가설이다.<br>

우선 B-Tree는 읽기 성능을 우선으로 했는데 쓰기를 할 때는 위치를 찾아서 수정해야 하고, 디스크 페이지를 자주 수정해야 한다.<br>
공간의 측면에서도 여유 공간을 미리 잡아두므로 오버헤드가 크다.<br>

반면, LSM Tree는 쓰기 성능을 우선으로 하여 순차적으로 데이터를 쌓아간다.<br>
하지만 결과를 모으려면 여러 SSTable을 읽어야 하므로 읽기 성능이 느려지고 중복 데이터가 저장되므로 공간 오버헤드가 발생한다.<br>

## Implementation Details
### Sorted String Tables
디스크에 상주하는 테이블은 SSTable로 구현된다.<br>
레코드들은 키 순서에 따라 정렬되어 존재하고,<br>
index file과 data file로 나뉜다.<br>

인덱스 파일은 로그 시간으로 조회가 가능한 B-Tree 같은 구조나, 상수 시간만에 조회가 가능한 hashtable로 구현된다.<br>
데이터 파일은 레코드가 key 순서로 정렬되어 있다.<br>

인덱스 컴포넌트는 키와 데이터 파일의 오프셋을 저장하고,<br>
데이터 파일은 키와 값의 쌍을 저장한다.<br>

데이터 파일은 이미 정렬되어 있으므로 인덱스 없이 순차 읽기 가능하다.<br>
즉, 병합 시 merge-iteration이 가능하다.<br>

### Bloom Filters
여러 SSTable을 읽어야 하는 경우 읽기 증폭이 발생할 수 있기 때문에 Bloom Filter를 사용하여 불필요한 SSTable을 읽지 않도록 한다.<br>

블룸 필터가 부정 결과를 반환하는 파일은 쿼리 과정에서 건너뛰고,<br>
긍정 결과를 반환하는 파일만 실제로 접근하여 데이터 레코드가 존재하는지 확인한다.<br>

큰 **비트 배열(Bit Array)**과 **여러 개의 해시 함수(Hash Function)**를 사용하여<br>
원소가 집합에 존재할 수 있는지 또는 절대 존재하지 않는지를 빠르게 판별한다.<br>

#### 저장
- 키에 여러 개의 해시 함수를 적용 
- 각 해시 함수 결과로 비트 배열의 인덱스를 얻음 
- 해당 위치의 비트를 1로 설정 
- 다른 키와 해시 함수 결과가 겹칠 경우 → 해시 충돌(Hash Collision) 발생 가능

### Skiplist
메모리에서 데이터를 정렬하여 보관하는 방식으로 skiplist를 사용한다.<br>
높이가 다른 여러 노드들로 구성되어 있으며, 링크를 이용해서 범위를 건너뛰는 계층 구조를 형성한다.<br>

노드의 높이는 랜덤 함수에 의해 결정되며, 삽입 시 계산된다.<br>
같은 높이를 가진 노드들은 하나의 레벨을 형성하고, 레벨의 수는 무한히 증가하지 않도록 제한된다.<br>

조회는 가장 높은 레벨의 노드 포인터를 따라가며 시작하고 찾고자하는 키보다 큰 키를 가진 노드를 만나면<br>
같은 레벨에서 앞 노드로 따라간다.<br>
반대의 경우에는 이전 노드의 더 낮은 링크로 이동한다.<br>

### Disk Access
페이지 캐시를 사용한다.<br>
하지만 불변 구조이므로 lock이나 latch 없이도 동시 접근이 가능하다.<br>
LSM 트리 내 데이터 레코드가 반드시 페이지 경계에 맞춰 정렬되어 있지 않고, 포인터를 페이지 ID 대신 absolute offset으로 구현할 수 있다.<br>

### Compression
압축을 하면 페이지의 크기보다 작아진다.<br>
이로 인해 경계 불일치 문제가 발생한다.<br>
indirection layer를 사용해서 압축 페이지의 오프셋과 크기를 별도의 매핑 테이블 같은 구조에 저장한다.<br>

## Unordered LSM Storage
데이터를 랜덤 순서로 저장하면 별도의 로그가 필요하지 않으며,<br>
쓰기 비용을 줄일 수 있다.<br>

### Bitcask
memtable을 사용하지 않고, 데이터를 직접 logfile에 저장한다.<br>
keydir라는 자료구조를 사용하는데, 이 구조에는 각 키에 해당하는 최신 데이터 레코드에 대한 참조가 저장된다.<br>

### WiscKey
정렬되지 않은 순서로 저장하더라도 범위 쿼리를 효율적으로 처리할 수 있는 방법이다.<br>
WiscKey는 정렬과 가비지 컬렉션을 분리하여, key는 LSM 트리 안에서 정렬된 상태로 유지하고,<br>
데이터 레코드는 vLogs라고 불리는 순서 없는 추가 전용 파일에 저장한다.<br>

vLog 파일에는 정렬되지 않은 데이터 레코드가 저장된다.<br>
key는 정렬된 LSM 트리에 저장되어, 로그 파일 내의 최신 데이터 레코드를 가리킨다.<br>

병렬 처리를 이용해 범위 스캔 중 블록을 병렬로 미리 읽어 랜덤 I/O 비용을 줄인다.<br>
하지만 범위 스캔 중 단일 데이터 레코드를 가져오려면 해당 레코드가 위치한 전체 페이지를 읽어야 한다.<br>
