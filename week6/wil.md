# Chapter 4. Implementing B-Trees

1. 조직화
- 첫 번째로, 키와 포인터 간의 관계를 설정하는 방법
- 페이지 간의 헤더 및 링크를 구현하는 방법

2. root-to-leaf 하강 과정
- 이진 검색을 수행하는 방법
- breadcrumb을 수집하는 방법

3. 최적화 방법, 유지보수 과정, 가비지 컬렉션

## Page Header
페이지 헤더는 내비게이션, 유지보수, 그리고 최적화에 사용될 수 있는 페이지에 대한 정보를 가진다.
- 페이지 내용과 레이아웃을 설명하는 플래그들
- 페이지 내 셀의 개수
- 빈 공간을 표시하는 하위 및 상위 오프셋
- 기타 유용한 메타데이터


### Magic Numbers
파일이나 페이지 헤더에 자주 나타남.<br>
일반적으로 이는 멀티바이트 블록으로, 해당 블록이 페이지를 나타내거나, 그 종류를 명시하거나, 버전을 식별하는 데 사용할 수 있는 상수 값을 포함합니다.

### 매직 넘버의 용도
- 검증과 무결성 검사에 활용 == 손상 감지
- 임의의 오프셋에서 바이트 시퀀스가 매직 넘버와 정확히 일치할 가능성은 희박. -> 일치한다면 맞을 가능성 높음


### Sibling Links
형제 페이지간 이동을 쉽게하기 위한 용도.<br>
부모 노드를 거칠 필요없이 바로 형제 노드로 점프 가능.<br>
대신 병합이나 분할 과정이 복잡해진다는 단점이 있긴 함.<br>
분할/병합의 당사자인 노드가 아니라 그 형제 노드에서도 update가 발생하므로,<br>
추가적인 lock이 요구됨

### Rightmost Pointers
B-Tree에서는 child tree의 수가 key의 수보다 하나 더 많기 때문에,<br>
최우측의 포인터는 header에 두기도 한다.<br>

최우측 자식이 분할되고 새로운 셀이 부모에 추가되면,가장 오른쪽 자식 포인터를 재할당해야 함.<br>
분할 후 부모에 추가된 셀은 승격된 키를 가지게 되고 분할된 노드를 가리킴.<br>
새로운 노드에 대한 포인터가 이전의 가장 오른쪽 포인터 대신 할당

### Node High Keys
최우측 포인터를 셀과 함께 노드의 **하이 키(high key)**와 저장할 수 있습니다.<br>
하이 키: 현재 노드 아래의 서브트리에 존재할 수 있는 가장 큰 키<br> PostgreSQL에서 사용하는 이 방식은 Blink-Tree라고 함.<br>

Blink-Tree에서는 각 노드에 K_N+1이라는 하이 키를 추가함.<br>
이 하이 키는 포인터 Pₙ이 가리키는 서브트리에 저장될 수 있는 값의 상한(upper bound)을 지정함.<br>
이렇게 하면 포인터와 키를 쌍으로 저장할 수 있어서 최우측 포인터에 대한 특별한 처리가 필요 없음.<br>

### Overflow Pages
B-Tree에서 노드 크기와 트리의 팬아웃은 고정되어 있어 동적으로 변경되지 않음.<br>

B-Tree 알고리즘은 각 노드가 특정 개수의 아이템을 유지하도록 한다.<br> 하지만 값의 크기가 다르면, 노드가 아직 "가득 차지 않았음"에도 실제로는 해당 노드를 담고 있는 고정 크기 페이지에 더 이상 공간이 없을 수 있다.<br>
낭비되는 공간이 있다는 뜻.<br>

이 문제를 해결하기 위해, 데이터를 새로운 연속 영역으로 복사하지 않고도 가변 크기 노드를 구현하는 방법이 있다.<br>
노드를 여러 개의 연결된 페이지로 구성하는 것.<br>

예를 들어, 기본 페이지 크기가 4KB이고, 데이터를 추가해 4KB를 초과하면 4KB 크기의 확장 페이지를 새로 할당하고, 원래 페이지에서 이 확장 페이지를 가리킨다.<br>
이렇게 연결된 확장 페이지를 **오버플로 페이지(overflow pages)**라고 부르고, 원래의 페이지는 **프라이머리 페이지(primary page)**라고 합니다.<br>

대부분의 B-Tree 구현은 노드에 직접 저장할 수 있는 페이로드(payload) 바이트 수에 제한을 두고, 그 이상은 오버플로 페이지에 저장한다.<br>
이 방식으로는 페이지에 항상 최소한 max_payload_size 바이트만큼의 공간이 남아 있게 되어, 공간 부족 문제가 발생하지 않는다.<br>
언젠가는 가득차겠지만, 낭비되는 공간이 없다는 의미로 받아들이면 될 듯.<br>

만약 삽입하려는 데이터가 max_payload_size를 초과하면,
해당 노드에 이미 오버플로 페이지가 있는지 확인한다.<br>
이미 있고 공간이 충분하면, 남은 데이터를 그곳에 저장하지만 반대의 경우, 새로운 오버플로 페이지를 할당해 데이터를 저장한다.<br>

#### 오버플로 페이지의 구조와 관리
첫 번째 오버플로 페이지가 할당되면, 그 페이지의 ID는 프라이머리 페이지의 헤더에 저장된다.<br>
오버플로 페이지가 둘 이상으로 늘어나면 여러 오버플로 페이지를 체인처럼 연결하고,<br>
각 오버플로 페이지의 헤더에는 다음 오버플로 페이지의 ID가 저장된다.<br>
즉, 특정 페이로드의 오버플로 부분을 찾으려면 여러 페이지를 순차적으로 따라가야 한다.<br>

## Binary Search
이진 검색은 정렬된 데이터에만 동작한다.<br>
따라서 키를 항상 정렬 상태로 유지하는 것이 매우 중요합니다.<br>

삽입 지점은 주어진 키보다 큰 첫 번째 요소의 인덱스이다.<br>
삽입은 해당 위치부터 오른쪽으로 요소들을 한 칸씩 밀어내는 방식으로 진행.<br>

근데 중요한 것은 정확한 일치(match)를 찾는 것이 아니라,<br>
검색 방향(어느 하위 트리로 내려갈지)을 결정하는 것이다.<br>

### Binary Search with Indirection Pointers
5주차에서 봤듯이 B-Tree 페이지의 셀들은 삽입 순서로 저장되지만, 논리적인 정렬 순서는 **셀 오프셋 배열(cell pointers)**이 유지한다.<br>
즉, 실제 데이터(셀)는 물리적으로는 삽입된 순서대로 저장되어 있지만,
셀 오프셋 테이블이 논리적(정렬된) 순서를 보장하는 역할을 합니다.

검색을 할 때는 중간 인덱스를 골라 해당 오프셋이 가리키는 셀부터 시작한다.<br>
셀 오프셋이 가리키는 셀에서 키 값을 읽어, 찾고자 하는 키와 비교하고,<br>
왼쪽/오른쪽으로 탐색 방향을 결정한다.<br>

## Propagating Splits and Merges
B-Tree에서의 분할과 병합은 상위 레벨로 전파될 수 있다.<br>
이를 위해서는, 루트 노드까지의 경로를 따라 거슬러 올라갈 수 있어야 한다.<br>

B-Tree 노드는 **부모 노드 포인터(parent node pointer)**를 포함할 수 있다.<br>
상위 레벨에서 하위 레벨의 페이지를 참조할 때마다 해당 페이지가 항상 메모리로 로드되기 때문에, 이 정보는 디스크에 저장하지 않아도 된다.<br>

sibling pointer와 마찬가지로, 부모 포인터도 부모가 변경될 때마다 반드시 갱신해야 한다.<br>
이러한 갱신은 분리자 키와 페이지 식별자가 한 노드에서 다른 노드로 이동할 때(즉, 부모 노드의 분할, 병합, 리밸런싱 발생 시) 발생한다.<br>

### Breadcrumbs
부모 노드 포인터를 저장하는 대신, 타깃 리프 노드까지의 경로를 기록해 두었다가,<br>
필요시에 이 경로(부모 노드 체인)를 역순으로 따라가는 방식이 가능하다.<br>

이를 Breadcrumbs라고 하는데, 루트부터 따라온 노드들의 참조를 담고 있다.<br>
가장 자연스러운 자료구조는 **스택(stack)**이고 실제로 PostgreSQL은 내부적으로 BTStack이라는 스택에 breadcrumbs를 저장한다고 한다.<br>