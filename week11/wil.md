# Chapter 6. B-Tree Variants
## Copy-on-Write
**Copy-on-Write**는 기존 노드를 직접 수정하지 않고, 복사본을 만들어 작업한 후,<br>
트리의 루트까지 연쇄적으로 복사를 전파한 뒤에 루트 포인터만 한 번에 바꿈.<br>
일관성, 원자성, 장애 복구 및 스냅샷 기능에 유리함.<br>

### **변경 전파 정리**

- **수정이 일어난 경로의 모든 노드** (리프 → 부모 → 조상 → 루트까지)  
  복사되어 새로운 버전을 생성하고, 변경사항을 반영.
- 마지막으로 **루트 포인터** 만 기존 루트에서 새로운 루트(복사본)로 교체.
- 이전 버전의 트리는 그대로 유지되고, **원자적 커밋** 가능.

**장점 요약**
- 트리의 변경 경로를 제외한 나머지는 재사용 가능.
- 트랜잭션 격리와 데이터 무결성 보장.
- 스냅샷, 장애 복구 등에서 높은 안정성.

### LMDB
- **키-값 기반의 초경량 데이터베이스 엔진**
- 메모리 매핑(memory-mapped file) 기법을 사용해 디스크의 데이터 파일을 프로세스 가상 메모리에 직접 연결
- 임베디드 시스템, 머신러닝/딥러닝 데이터셋, 인메모리 캐시 등 다양한 분야에서 널리 활용

## 동작 방식
- **데이터 파일을 메모리에 매핑**
    - 한 번에 파일 전체가 가상 메모리에 맵핑
    - OS가 필요한 데이터만 실제 물리 메모리로 페이지 단위로 불러옴(가상 메모리 관리와 동일)
    - 사용자 입장에서는 모든 데이터가 메모리에 있는 것처럼 접근 가능
- **Copy-on-Write(COW) 구조**
    - 데이터 수정 시, 바뀐 부분과 해당 상위 노드만 새로 복사해 디스크에 기록
    - 전체 파일이 아니라 변경된 블록만 효율적으로 라이트

## 파일/레코드 구조
- **테이블(혹은 데이터베이스 전체)은 보통 하나의 파일로 관리**
- 그 파일 안에 모든 레코드, 인덱스, 메타데이터가 포함됨

## 읽기/쓰기의 효율성
- **읽기:**  별도의 캐시 없이 운영체제의 메모리 매핑만으로 빠른 접근
- **쓰기:**  전체를 다시 쓰는 게 아니라, 수정된 데이터와 그와 연결된 상위 노드만 덮어씀

## 왜 '가볍다'고 하는가?
- 자체 캐시, 로그, 복잡한 관리 구조 없이 단순히 파일-메모리 매핑으로 동작
- 데이터 이동·복제·관리 오버헤드가 적고, 운영체제의 캐시 메커니즘을 그대로 활용
- 변경(쓰기) 시 전체 파일을 다시 쓰지 않고 필요한 조각만 덮어줘서 디스크 IO 효율적

## 대표적인 사용 예시
- **OpenLDAP:** 고성능 디렉터리 서비스에서 LMDB를 기본 데이터베이스 엔진으로 사용


## Abstracting Node Updates
- **B-Tree 노드**는 디스크에 *raw binary* 형태로 저장됨
- 해당 페이지(노드)를 사용할 때 **메모리로 불러와서 가공/수정**하게 됨
- 이때, 디스크에서 불러온 binary 데이터를 **메모리에서 어떻게 표현하고 갱신할지**가 구현 방식에 따라 크게 다름

#### 메모리 내 노드 표현 방식
1. **Raw binary & 포인터/구조체 직접 접근**<br>
binary 데이터를 메모리로 올리고, 포인터와 구조체 캐스팅을 통해 해석 및 수정<br>
메모리 효율 높지만, 동시성·안전성 관리 필요
2. **언어 네이티브 객체/구조체로 변환**<br>
데이터를 언어나 프레임워크 구조체나 객체로 파싱 후 처리<br>
구현 쉽고 안전/메모리 사용량 증가<br>
3. **버퍼 래퍼 객체 사용**<br>
버퍼를 감싸는 객체(wrapper)로 변경시마다 바로 binary에 적용<br>
동시성·버퍼링 유연/관리형 언어에서 주로 사용<br>


## Lazy B-Trees
### WiredTiger
### Lazy-Adaptive Tree

## FD-Trees
### Fractional Cascading
### Logarithmic Runs
